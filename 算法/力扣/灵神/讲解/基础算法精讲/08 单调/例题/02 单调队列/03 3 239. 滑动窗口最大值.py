from collections import deque
from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        q = deque() # 使用双端队列构造单调队列 
        
        for i, x in enumerate(nums):
            # 元素索引“入”队列逻辑 
            while q and nums[q[-1]] <= x:
                q.pop()
            # 先检查是否又比当前元素小的元素的索引，如果有的话，从队列中将其删除。 
            q.append(i)
            # 删完了之后加入当前元素的索引。 
            
            # 元素索引“出”队列逻辑 
            if i - q[0] + 1 > k:
                q.popleft()
            # 如果队列长度大于题目所给的滑动窗口长度，那么将队首元素弹出队列。 
            
            # 记录答案逻辑 
            if i >= k - 1:
                ans.append(nums[q[0]])
            # 因为实际上是索引大于等于k - 1的时候才开始记答案，所以要用if语句控制答案开始记录的时机。 
            # 因为q中保存的是答案元素的索引，所以要引用完q中元素之后使用其引用到可作为答案的元素，然后加入到答案列表里。 

        return ans 
        # 最后返回答案。 

# 因为要删除队尾元素也要删除队首元素，所以此算法被称为单调队列算法，和单调栈只删一端的做法有明显区别。 

# 2025.12.30 23:57 

# 虽然有二重循环，但是因为每个元素最多入队列一次、出队列一次，所以 
# 时间复杂度O(n) 

# 因为除答案列表外要用长度为k的队列保存元素索引，所以粗略来说 
# 空间复杂度O(k) 

# 而严格来说，因为当前使用的算法会删除相同元素的索引，所以实际情况下队列中的元素数量可能小于k， 
# 如果用U = len(set(nums))来表示nums数组中不同元素的个数，那么严格来说 
# 空间复杂度O(min(k, U)) 

# 2025.12.31 00:10 

# 2025.12.31 00:18 

# 到此，基础算法精讲第一遍速通完结。 
# 2025.12.31 00:21 