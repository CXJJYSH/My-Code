# 双指针写法 

class Solution:
    def reversePrefix(self, s: str, k: int) -> str:
        s = list(s) 
        
        left = 0
        right = k - 1
        
        while left < right:
            s[left], s[right] = s[right], s[left] 
        
            left += 1
            right -= 1
        
        return "".join(s) 

# 时间复杂度O(n) 
# 空间复杂度O(n) 

# 2026.02.07 14:36 

# 库函数写法 

class Solution:
    def reversePrefix(self, s: str, k: int) -> str:
        return s[:k][::-1] + s[k:]
    
# 先取长度为k的字符串片段，反转，再拼接。 

# 时间复杂度O(n)或O(k)，取决于能否原地修改字符串。 
# 空间复杂度O(n)或O(1)，取决于能否原地修改字符串。 

# 2026.02.07 14:53 

# GPT对为什么要“取决于能否原地修改字符串”这个条件的解释。 

# 这段代码中，s[:k][::-1] 和 s[k:] 都涉及到字符串切片和反转操作。 
# 让我们逐步分析为什么空间复杂度和时间复杂度会受到能否原地修改字符串的影响。 

# 时间复杂度 

# O(n)：因为在 Python 中，字符串是不可变的。 
# 如果你要修改字符串的一部分（例如反转前 k 个字符），实际上会创建一个新的字符串来存储修改后的内容。 
# 这就导致了整体的时间复杂度是线性关系，即 O(n)，其中 n 是字符串 s 的长度。


# O(k)：如果 Python 允许在原地修改字符串，那么你就只需要修改前 k 个字符，这时操作的时间复杂度是 O(k)，而不是 O(n)。 
# 但是在 Python 中，字符串不能原地修改，因此我们还是会按照 O(n) 计算时间复杂度。 

# 空间复杂度 


# O(n)：由于字符串不可变，反转字符串时需要创建一个新的字符串，这就导致了额外的空间开销。 
# 如果我们反转的是前 k 个字符，Python 仍然需要创建一个新的字符串来存储反转后的部分，以及原字符串剩余部分（s[k:]）。 


# O(1)：如果字符串可以原地修改（例如使用可变数据类型如 list），那么就不需要额外的空间来存储反转的部分，这时空间复杂度为 O(1)。 
# 但在实际应用中，Python 字符串不可原地修改，所以我们依然考虑 O(n) 的空间复杂度。 

# 总结

# 虽然时间和空间复杂度通常是 O(n)，但在理论上，如果能够原地修改字符串，时间和空间复杂度可以降到 O(k)，因为我们只需要操作前 k 个字符。 
# 这就是为什么要考虑能否原地修改字符串。 

# 2026.02.07 15:02 